
###FilePath: label/index.tsx

import React, {FC} from 'react';
import {Text} from 'react-native';
import {getStyles} from './styles';
import {LabelProperties} from './types';
import {
  getCurrentLanguage,
  useNewTheme,
  Language,
  ContextualType,
} from 'react-core';
import Animated from 'react-native-reanimated';
const Label: FC<LabelProperties> = (properties: LabelProperties) => {
  const {
    id,
    variant = ContextualType.bodyRegularM,
    text,
    style,
    numberOfLines,
    textProps,
  } = properties;
  const theme = useNewTheme();
  const language = getCurrentLanguage() as Language;
  const styles = getStyles({theme, language, variant});

  return (
    <Animated.Text
      key={id}
      numberOfLines={numberOfLines}
      style={[styles.labelStyle, style]}
      {...textProps}>
      {text}
    </Animated.Text>
  );
};

export {Label};


###FilePath: label/styles.ts

import {Platform, StyleSheet} from 'react-native';
import {LabelStyleProperties} from './types';
import {getFontStyles, Language} from 'react-core';

export const getStyles = (props: LabelStyleProperties) => {
  const {theme, language, variant} = props;
  const fontStyles = getFontStyles(variant, language);
  return StyleSheet.create({
    labelStyle: {
      color: theme.colors['content-primary'],
      textAlign: 'left',
      textAlignVertical: 'center',
      // ...Platform.select({
      //   ios: {
      //     transform: [{ translateY: 10 }]
      //   }
      // }),
      // transform: [{ translateY: -25 }],
      // height: 32,
      ...(language === Language.Arabic ? {paddingTop: 5} : {}),
      // backgroundColor: 'red',
      ...fontStyles,
      ...Platform.select({
        android: {
          // fontFamily: 'Vazirmatn-Medium',
          // fontFamily: 'Vazirmatn-Regular',
          // fontFamily: 'Vazirmatn-SemiBold',
          // fontWeight: undefined
        },
        // ios: {
        //   // fontFamily: 'Vazirmatn'
        //   fontFamily: 'Vazirmatn-SemiBold',
        //   fontWeight: undefined
        // }
      }),

      // ...Platform.select({
      //   android: {
      //     fontFamily: fontStyles.fontFamily.replaceAll(' ', '')
      //   },
      // }),
    },
  });
};


###FilePath: label/types.ts

import { Language, ContextualType, Theme } from 'react-core';
import { StyleProp, TextProps, TextStyle } from 'react-native';

// export enum variants {
//   titleXL = 'titleXL',
//   titleL = 'titleL',
//   titleM = 'titleM',
//   titleS = 'titleS',
//   titleXS = 'titleXS',
//   bodySemiBoldL = 'bodySemiBoldL',
//   bodyMediumL = 'bodyMediumL',
//   bodyRegularL = 'bodyRegularL',
//   bodySemiBoldM = 'bodySemiBoldM',
//   bodyMediumM = 'bodyMediumM',
//   bodyRegularM = 'bodyRegularM',
//   bodySemiBoldS = 'bodySemiBoldS',
//   bodyMediumS = 'bodyMediumS',
//   bodyRegularS = 'bodyRegularS',
//   bodySemiboldXS = 'bodySemiboldXS',
//   bodyMediumXS = 'bodyMediumXS',
//   bodyRegularXS = 'bodyRegularXS',
// }

export { ContextualType as variants }

export interface LabelProperties {
  id: string;
  text: string;
  variant?: ContextualType;
  style?: StyleProp<TextStyle>;
  numberOfLines?: number;
  textProps?: TextProps;
}
export interface LabelStyleProperties {
  theme: Theme;
  language: Language;
  variant: ContextualType;
}


###FilePath: custom-checkbox-button/index.tsx

import {Pressable, View} from 'react-native';
import React, {FC} from 'react';
import {CheckboxButtonProperties} from './types';
import {getStyle} from './styles';
import {IconAlertCircle} from '@app/assets/svg/icon-alert-circle';
import {IconAlertCircleInverted} from '@app/assets/svg/icon-alert-circle-inverted';
import {Theme, useNewTheme} from 'react-core';
import {Label} from '../label';
import {Link} from '../link';
import {variants} from '../label/types';
import {Tick02} from 'app/assets/svg';
import {linkVariant} from '../link/types';

const CustomCheckbox: FC<CheckboxButtonProperties> = (
  properties: CheckboxButtonProperties,
) => {
  const {
    id,
    onPress,
    title,
    isChecked,
    inverted,
    linkTitle,
    onPressLink,
    errorText,
    style,
    innerContainerStyle,
    disabled = false,
    titleStyle,
    titleVariant = variants.bodyRegularM,
    onPressDisabled = false,
    buttonStyle,
  } = properties;
  const theme: Theme = useNewTheme();
  const styles = getStyle(theme, isChecked, disabled, inverted);
  const getCheckboxStyle = () => {
    if (inverted) {
      return errorText !== ''
        ? styles.errorInverted
        : !disabled
        ? styles.inverted
        : styles.disabled;
    }
    if (disabled) {
      return styles.disabled;
    }
    if (errorText?.length) {
      return styles.error;
    }
    return styles.default;
  };
  const buttonStyles = getCheckboxStyle();
  return (
    <View key={id} style={[styles.container, style]}>
      <View style={[styles.innerContainer, innerContainerStyle]}>
        <Pressable
          onPress={onPress}
          style={[buttonStyles, buttonStyle]}
          disabled={onPressDisabled}>
          {isChecked ? <Tick02 /> : ''}
        </Pressable>
        {(title || linkTitle) && (
          <View style={styles.labelContainer}>
            {title && (
              <Label
                id="custom-checkbox-button"
                text={title}
                variant={titleVariant}
                style={[styles.title, titleStyle]}
              />
            )}

            {linkTitle && (
              <Link
                id={'link-' + id}
                linkText={' ' + linkTitle}
                onPress={onPressLink}
                variant={linkVariant.large}
              />
            )}
          </View>
        )}
      </View>
      {errorText && (
        <View style={styles.errorContainer}>
          {inverted ? <IconAlertCircleInverted /> : <IconAlertCircle />}
          <Label
            id="custom-checkbox-button"
            text={errorText}
            variant={variants.bodyRegularXS}
            style={styles.errorTitle}
          />
        </View>
      )}
    </View>
  );
};

export {CustomCheckbox};


###FilePath: custom-checkbox-button/styles.ts

import { Theme } from 'react-core';
import { StyleSheet } from 'react-native';

export const getStyle = (
  theme: Theme,
  isChecked?: boolean,
  disabled?: boolean,
  inverted?: boolean,
) => {
  return StyleSheet.create({
    container: {
      justifyContent: 'flex-start',
      flexDirection: 'column',
      gap: 8,
      flexShrink: 1,
    },
    innerContainer: {
      flexDirection: 'row',
      flexShrink: 1,
      gap: 8  //as per figma
    },
    labelContainer: {
      flexDirection: 'row',
      flexShrink: 1
    },
    errorContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      flexShrink: 1,
    },
    title: {
      // fontSize: 16,
      color: disabled
        ? theme.colors['content-disabled']
        : theme.colors['content-primary'],
    },
    linkText: {
      fontSize: 16,
      color: theme.colors['content-interactive-primary-enabled'],
    },
    errorTitle: {
      color: inverted
        ? theme.colors['content-semantic-error-inverted']
        : theme.colors['border-semantic-error'],
      marginHorizontal: 4,
    },
    default: {
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: isChecked
        ? theme.colors['surface-interactive-tertiary-active']
        : theme.colors['surface-interactive-primary-inverted-enabled'],
      height: 24,
      width: 24,
      borderRadius: 4,
      borderWidth: isChecked ? 0 : 1,
      borderColor: isChecked ? '' : theme.colors['border-interactive-enabled'],
    },
    inverted: {
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: isChecked
        ? theme.colors['surface-interactive-primary-inverted-active']
        : theme.colors['surface-interactive-primary-inverted-enabled'],
      height: 24,
      width: 24,
      borderRadius: 4,
      borderWidth: 1,
      borderColor: isChecked ? '' : theme.colors['border-interactive-enabled'],
    },
    disabled: {
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: isChecked
        ? theme.colors['surface-interactive-primary-inverted-enabled']
        : theme.colors['surface-interactive-primary-inverted-enabled'],
      height: 24,
      width: 24,
      borderRadius: 4,
      borderWidth: 1,
      borderColor: isChecked
        ? theme.colors['border-interactive-disabled']
        : theme.colors['border-interactive-disabled'],
    },
    error: {
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: isChecked
        ? theme.colors['surface-semantic-error-02']
        : theme.colors['surface-semantic-error-01'],
      height: 24,
      width: 24,
      borderRadius: 4,
      borderWidth: 1,
      borderColor: isChecked ? '' : theme.colors['border-semantic-error'],
    },
    errorInverted: {
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: isChecked
        ? theme.colors['surface-semantic-inverted-error-02']
        : theme.colors['surface-semantic-error-01'],
      height: 24,
      width: 24,
      borderRadius: 4,
      borderWidth: 1,
      borderColor: isChecked
        ? ''
        : theme.colors['border-semantic-error-inverted'],
    },
  });
};


###FilePath: custom-checkbox-button/types.ts

import {TextStyle, ViewStyle} from 'react-native';
import {ContextualType} from 'react-core';

export interface CheckboxButtonProperties {
  id: string;
  onPress?: () => void;
  title?: string | React.ReactElement;
  isChecked: boolean;
  inverted?: boolean;
  style?: ViewStyle;
  onPressLink?: () => void;
  innerContainerStyle?: ViewStyle;
  errorText?: string;
  linkTitle?: string;
  disabled?: boolean;
  titleStyle?: TextStyle;
  titleVariant?: ContextualType;
  onPressDisabled?: boolean;
  buttonStyle?: ViewStyle;
}


###FilePath: screen/index.tsx

import React, {FC, useEffect, useLayoutEffect, useRef, useState} from 'react';

import {
  View,
  Pressable,
  Platform,
  StatusBar,
  ScrollView,
  KeyboardAvoidingView,
  Dimensions,
  Keyboard,
  Animated,
  Text,
  NativeSyntheticEvent,
  NativeScrollEvent,
} from 'react-native';
import {useNewTheme, Theme} from 'react-core';

import {CustomCheckbox} from '../custom-checkbox-button';
import LinearContainer from '../linear-gradient';
import {getStyles} from './styles';
import {ScreenContainerProperties} from './types';
import {ArrowBackIcon} from '@app/assets/svg';
import {useFocusEffect, useNavigation} from '@react-navigation/native';
import useKeyboardVisible from 'app/hooks/useKeyboardVisible';
import useStatusBarheight from 'app/hooks/useStatusBarHeight';
import useAppColourScheme from 'app/hooks/useAppColourScheme';

import {ShadowDivider} from '../shadow-divider';
import LinearGradient from 'react-native-linear-gradient';
import {
  interpolate,
  useAnimatedStyle,
  useSharedValue,
} from 'react-native-reanimated';
import {SCROLL_SHADOW_OFFSET, SCROLL_SHADOW_OPACITY_MAX} from 'app/constants';
import {StickyShadows} from '../sticky-shadows';
import {StickyShadowDirections} from '../sticky-shadows/types';
import {useScrollShadow} from 'app/hooks/use-scroll-shadow';

const ScreenContainer: FC<ScreenContainerProperties> = ({
  id,
  children,
  inverted = false,
  circleRadiusButtomGlow = false,
  showStatusBar = true,
  showRightContent = false,
  showCenterContent = false,
  bottomScreenContent,
  stickyKeyboardBottomView = false,
  showCheckbox = false,
  isChecked = false,
  disabled = false,
  onPressLeftContent,
  onPressCenterContent,
  onPressRightContent,
  leftContent,
  centerContent,
  rightContent,
  scrollViewStyle,
  onPressCheckbox,
  showGoBackIcon = false,
  customContainerStyle,
  customBottomScreenContentStyle,
  headerContainerStyle,
  backgroundColor,
  disableKeyboardAvoidingScrollView = false,
  disableScrollView = false,
  removeBottomInsets = false,
  bounceOnscroll = true,
  keyboardContainerStyle,
  stickyContent = null,
  disableBottomSafeArea = false,
  customStickyBottomPadding = 24,
  disableInvertedNavigationBar = false,
  shadowVisible = true,
  loginPage = false,
  onScrollRef = null,
  ...scrollViewProps
}) => {
  const theme: Theme = useNewTheme();
  const navigation = useNavigation();
  const statusBarHeight = useStatusBarheight();
  // const keyBoardVertical =
  //   (statusBarHeight ?? 24) - (Platform.OS === 'ios' ? 16 : 24);
  const styles = getStyles({
    theme,
    inverted,
    statusBarHeight,
    customStickyBottomPadding,
  });
  // const isKeyboardVisible = useKeyboardVisible().isKeyboardVisible;
  const [keyBoardOffset, setKeyBoardOffset] = useState(keyBoardVertical);
  const {navigationBarColor, navigationBarColorInverted} = useAppColourScheme();
  // const scrollViewEnabled = disableScrollView
  //   ? false
  //   : Dimensions.get('window').height > 700
  //   ? true
  //   : false;

  const [isKeyboardVisible, setIsKeyboardVisible] = useState(false);
  const [keyBoardVertical, setKeyBoardVertical] = useState(0);

  useEffect(() => {
    const showSubscription = Keyboard.addListener('keyboardDidShow', e => {
      setIsKeyboardVisible(true);
      setKeyBoardVertical(e.endCoordinates.height);
    });
    const hideSubscription = Keyboard.addListener('keyboardDidHide', () => {
      setIsKeyboardVisible(false);
      setKeyBoardVertical(0);
    });

    return () => {
      showSubscription.remove();
      hideSubscription.remove();
    };
  }, []);

  const goBack = () => {
    navigation?.goBack();
  };

  useFocusEffect(() => {
    if (Platform.OS === 'android') {
      //for 3 button navigation bar color
      navigation.setOptions({
        navigationBarColor:
          inverted && !disableInvertedNavigationBar
            ? navigationBarColorInverted
            : navigationBarColor,
      });
      return () => {
        navigation.setOptions({
          navigationBarColor: navigationBarColor,
        });
      };
    }
  });

  // useEffect(() => {
  //   isKeyboardVisible
  //     ? setKeyBoardOffset(keyBoardVertical)
  //     : setKeyBoardOffset(0);
  // }, [isKeyboardVisible, keyBoardVertical]);

  const statusBackgroundColor = () => {
    if (backgroundColor) {
      return backgroundColor;
    } else if (inverted) {
      return 'transparent';
    } else return theme.colors['background-01'];
  };

  const scrollViewRef = useRef<ScrollView>(null);
  // const scrollY = useRef(new Animated.Value(0)).current;
  // const [prevScrollY, setPrevScrollY] = useState(0);
  // const headerOpacity = scrollY.interpolate({
  //   inputRange: [0, 100], // Adjust 100 to control fade-out distance
  //   outputRange: [1, 0],
  //   extrapolate: 'clamp',
  // });
  // const handleScroll = Animated.event(
  //   [{nativeEvent: {contentOffset: {y: scrollY}}}],
  //   {
  //     useNativeDriver: false, // Set to true if not animating layout properties like height/width
  //     listener: event => {
  //       const currentScrollY = event?.nativeEvent.contentOffset.y;
  //       // You can add logic here to determine scroll direction if needed for more complex animations
  //       // For simple fade based on scroll position, the interpolate handles it.
  //       setPrevScrollY(currentScrollY);
  //     },
  //   },
  // );

  useEffect(() => {
    if (onScrollRef) onScrollRef(scrollViewRef.current);
  }, []);

  /* New Shadow Scroll */
  const {
    scrollable,
    topShadowOpacity,
    bottomShadowOpacity,
    handleScroll,
    handleScrollHeight,
    handleContentSizeChange,
  } = useScrollShadow();

  return (
    <LinearContainer
      style={[
        {
          backgroundColor: backgroundColor ?? theme.colors['background-01'],
        },
        removeBottomInsets && {paddingBottom: 0},
      ]}
      inverted={inverted}
      loginPage={loginPage}
      disableBottomSafeArea={disableBottomSafeArea}
      circleRadiusButtomGlow={circleRadiusButtomGlow}>
      <KeyboardAvoidingView
        style={[styles.keyboardContainer, keyboardContainerStyle]}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        enabled={!disableKeyboardAvoidingScrollView && isKeyboardVisible}
        keyboardVerticalOffset={keyBoardOffset}
        contentContainerStyle={styles.keyboardContentContainer}>
        <View
          style={[styles.containerStyle, customContainerStyle]}
          id={id}
          testID={id}>
          {showStatusBar && (
            <StatusBar
              translucent
              barStyle={inverted ? 'light-content' : 'dark-content'}
              animated
              backgroundColor={statusBackgroundColor()}
            />
          )}
          {/* This view showing extra top space in */}
          {/* <View style={styles.safeAreaStyle}> */}
          {/* Header Bar */}
          <View style={[styles.headerContainerStyle, headerContainerStyle]}>
            {/* Left Header */}

            <View style={styles.leftContainerStyle}>
              {showGoBackIcon ? (
                <Pressable style={styles.leftContentStyle} onPress={goBack}>
                  <ArrowBackIcon
                    color={
                      inverted
                        ? theme.colors['icon-interactive-inverted-enabled']
                        : theme.colors['icon-interactive-secondary-enabled']
                    }
                  />
                </Pressable>
              ) : (
                leftContent && (
                  <Pressable
                    focusable={false}
                    style={styles.leftContentStyle}
                    onPress={onPressLeftContent}>
                    {leftContent}
                  </Pressable>
                )
              )}
            </View>

            {/* Middle Label */}
            <View style={styles.centerContainerStyle}>
              {showCenterContent && (
                <Pressable
                  style={styles.centerLogoStyle}
                  onPress={onPressCenterContent}>
                  {centerContent}
                </Pressable>
              )}
            </View>

            {/* Right Header */}
            <View style={styles.rightContainerStyle}>
              {showRightContent && (
                <Pressable
                  style={styles.rightLogoStyle}
                  onPress={onPressRightContent}>
                  {rightContent}
                </Pressable>
              )}
            </View>
            {/* </View> */}
          </View>
          {/* {shadowVisible && (
            <ShadowDivider height={16} sides={{bottom: true, top: false}} />
          )} */}
          {stickyContent}

          <View style={{flex: 1}}>
            {shadowVisible && (
              <Animated.View style={{opacity: topShadowOpacity, zIndex: 10}}>
                <StickyShadows />
              </Animated.View>
            )}
            <Animated.ScrollView
              onLayout={handleScrollHeight}
              onContentSizeChange={handleContentSizeChange}
              onScroll={e => {
                // scrollY.value = e.nativeEvent.contentOffset.y;
                handleScroll(e);
              }}
              scrollEnabled={!disableScrollView}
              keyboardShouldPersistTaps="handled"
              contentContainerStyle={scrollViewStyle}
              bounces={false}
              {...scrollViewProps}
              ref={scrollViewRef}>
              {children}
            </Animated.ScrollView>
            {shadowVisible && scrollable && !isKeyboardVisible && (
              <Animated.View
                style={{
                  opacity: bottomShadowOpacity,
                  zIndex: 10,
                }}>
                <StickyShadows
                  direction={StickyShadowDirections.BOTTOM_TO_TOP}
                  containerStyle={{
                    top: -16,
                  }}
                />
              </Animated.View>
            )}
          </View>
          {showCheckbox && (
            <View style={styles.checkboxContainerStyle}>
              <CustomCheckbox
                id="checkbox"
                onPress={onPressCheckbox}
                errorText=""
                title="Checkbox"
                isChecked={isChecked}
                inverted={inverted}
                disabled={disabled}
              />
            </View>
          )}
          <View
            style={[
              styles.bottomScreenContentStyle,
              customBottomScreenContentStyle,
              // shadowVisible && !isKeyboardVisible && styles.bottomShadowStyle,
              stickyKeyboardBottomView && isKeyboardVisible
                ? styles.stickyKeyboardBottomView
                : {},
            ]}>
            {bottomScreenContent}
          </View>
        </View>
      </KeyboardAvoidingView>
    </LinearContainer>
  );
};

export {ScreenContainer};


###FilePath: screen/styles.ts

import {StyleSheet, Dimensions, Platform} from 'react-native';
import {ScreenContainerStypeProps} from './types';
import DeviceInfo from 'react-native-device-info';
import useKeyboard from 'app/hooks/useKeyboardVisible';
import {useSafeAreaInsets} from 'react-native-safe-area-context';
import useNavigationBarHeight from 'app/hooks/useNavigationBarHeight';

const {width, height} = Dimensions.get('window');
const isTab = DeviceInfo.isTablet();
const isPadOrTab = isTab && (width >= 768 || height >= 1024);

export const getStyles = (properties: ScreenContainerStypeProps) => {
  const insets = useSafeAreaInsets();
  const {isKeyboardVisible, keyboardHeight} = useKeyboard();
  const {navBarHeight} = useNavigationBarHeight();

  // const isKeyBoardVisible = useKeyboardVisible()?.isKeyboardVisible;
  const {
    theme,
    inverted,
    statusBarHeight,
    customStickyBottomPadding = 24,
  } = properties;
  return StyleSheet.create({
    containerStyle: {
      flex: 1,
      backgroundColor: inverted ? undefined : theme.colors['background-01'],
    },
    keyboardContainer: {
      flex: 1,
    },

    keyboardContentContainer: {
      paddingBottom: 150,
      padding: 20,
      margin: 50,
    },
    headerContainerStyle: {
      height: 40,
      width: '100%',
      justifyContent: 'center',
      ...Platform.select({
        ios: {
          paddingTop: 0,
        },
        android: {
          marginTop: inverted ? statusBarHeight : 0,
        },
      }),
      flexDirection: 'row',
      marginBottom: 8,
    },
    leftContainerStyle: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-start',
    },
    centerContainerStyle: {
      flex: 1,
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
    },
    rightContainerStyle: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'flex-end',
    },
    centerLogoStyle: {
      position: 'absolute',
      alignSelf: 'center',
      height: 40,
      justifyContent: 'center',
    },
    rightLogoStyle: {
      position: 'absolute',
      alignSelf: 'flex-end',
      height: 40,
      justifyContent: 'center',
      right: 16,
    },
    leftContentStyle: {
      position: 'absolute',
      left: 16,
      height: 40,
      justifyContent: 'center',
      alignItems: 'flex-start',
      width: 40,
    },
    checkboxContainerStyle: {
      flex: 1,
      alignItems: 'center',
      justifyContent: 'center',
    },
    // bottomScreenContentStyle: {
    //   ...Platform.select({
    //     ios: {
    //       paddingBottom: isKeyBoardVisible ? (height < 700 ? 24 : 62) : 24,
    //     },
    //     android: {
    //       paddingBottom: 24,
    //     },
    //   }),
    // },
    bottomScreenContentStyle: {
      ...Platform.select({
        ios: {
          paddingBottom: isKeyboardVisible
            ? height < 700
              ? 24
              : insets.top
            : 24,
        }, //ios
        android: {
          paddingBottom: isKeyboardVisible
            ? navBarHeight - 16 // to remove the excess padding on keyboard alive
            : navBarHeight + 24,
          // paddingBottom: navBarHeight + 24, // padding for CTA across the ScreenConatainer.
        },
      }),
    },
    bottomShadowStyle: {
      boxShadow: '0 -8px 12px 0 rgba(0, 0, 0, 0.10))',
    },
    topBar: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 1,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
      elevation: 5,
    },

    linearGradient: {
      height: 10,
      width: '100%',
    },

    stickyKeyboardBottomView: {
      position: 'absolute',
      left: 0,
      right: 0,
      bottom: isKeyboardVisible ? keyboardHeight : 0,
      paddingBottom: customStickyBottomPadding,
    },
    safeAreaStyle: {
      paddingTop: isPadOrTab ? 25 : 0,
    },
    stickyShadowTop: {
      zIndex: 1,
      top: 0,
      bottom: null
    },
    stickyShadowBottom: {
     zIndex: 1,
     bottom: 0,
     top: null
    },
  });
};


###FilePath: screen/types.ts

import {Theme} from 'react-core';
import React, {ReactNode} from 'react';
import {StyleProp, ViewStyle,ScrollView} from 'react-native';

export interface ScreenContainerProperties {
  id: string;
  children?: ReactNode;
  inverted?: boolean;
  showStatusBar?: boolean;
  circleRadiusButtomGlow?: boolean;
  bottomScreenContent?: ReactNode;
  stickyKeyboardBottomView?: boolean;
  showStory?: boolean;
  showRightContent?: boolean;
  showCenterContent?: boolean;
  showCheckbox?: boolean;
  isChecked?: boolean;
  disabled?: boolean;
  onPressCheckbox?: () => void;
  onPressLeftContent?: () => void;
  onPressCenterContent?: () => void;
  onPressRightContent?: () => void;
  leftContent?: React.JSX.Element;
  stickyContent?: ReactNode;
  centerContent?: React.JSX.Element;
  rightContent?: React.JSX.Element;
  scrollViewStyle?: StyleProp<ViewStyle>;
  showGoBackIcon?: boolean;
  customContainerStyle?: StyleProp<ViewStyle>;
  customBottomScreenContentStyle?: StyleProp<ViewStyle>;
  headerContainerStyle?: StyleProp<ViewStyle>;
  backgroundColor?: string;
  disableKeyboardAvoidingScrollView?: boolean;
  disableScrollView?: boolean;
  showsHorizontalScrollIndicator?: boolean;
  showsVerticalScrollIndicator?: boolean;
  removeBottomInsets?:boolean
  bounceOnscroll?: boolean;
  keyboardContainerStyle?: ViewStyle;
  disableBottomSafeArea?:boolean; //supports for iOS
  customStickyBottomPadding?: number;
  disableInvertedNavigationBar?: boolean;
  shadowVisible?: boolean;
  loginPage?: boolean;
  onScrollRef?: (a:ScrollView) => void;

}

export interface ScreenContainerStypeProps {
  theme: Theme;
  inverted: boolean;
  statusBarHeight: number;
  customStickyBottomPadding?: number;
}


###FilePath: submit-button/index.tsx

import React, {FC} from 'react';
import {Button, ButtonProperties} from '../custom-button';
import useKeyboardVisible from 'app/hooks/useKeyboardVisible';
import {View, StyleSheet} from 'react-native';

const SubmitButton: FC<ButtonProperties> = props => {
  const isKeyBoardVisible = useKeyboardVisible()?.isKeyboardVisible;
   const { paddingHorizontal, ...restProps } = props;
  const effectivePadding = isKeyBoardVisible ? 0 : (paddingHorizontal ?? 16);
  return (
       <View style={[!isKeyBoardVisible &&  { paddingHorizontal: effectivePadding }]}>
      <Button isSubmitButton={isKeyBoardVisible} {...restProps} />
    </View>
  );
};


export {SubmitButton};


###FilePath: custom-input/index.tsx

import React, {FC, useEffect, useRef, useState} from 'react';
import {
  Animated,
  Easing,
  Image,
  Keyboard,
  NativeSyntheticEvent,
  Pressable,
  Text,
  TextInput,
  TextInputFocusEventData,
  View,
} from 'react-native';
import {
  getCurrencyComponentStyle,
  getFlagComponentStyle,
  getStyle,
} from './styles';
import {useNewTheme, translation, Theme} from 'react-core';
import {InputProperties} from './type';
import {Cancel_01} from 'app/assets/svg';
import EyeOpenComponent from '@app/assets/svg/eye-open';
import {EyeCloseComponent} from '@app/assets/svg/eye-close';
import {ErrorText} from '../error-text';
import {HelperText} from '../helper-text';
import {Label} from '../label';

import {
  ALPHA_NUMERIC_ARABIC_REGEX,
  ALPHA_NUMERIC_ARABIC_WITH_SPACE_REGEX,
  ALPHA_NUMERIC_REGEX,
  ALPHA_NUMERIC_WITH_SPACE_REGEX,
  ARABIC_REGEX,
  EMOJI_REGEX,
  KeyboardTypes,
  NUMERIC_REGEX,
} from 'app/constants';
import {variants} from '../label/types';
import RemoteSvg from '../remote-svg';
import {formatIbanWithSpaces, Size} from 'app/utils';
import {Currency} from '../Currency';
import {isRTLLanguage} from 'app/utils/language-utils';

const Input: FC<InputProperties> = (
  properties: InputProperties,
): JSX.Element => {
  const {
    id,
    disabled = false,
    placeholder = '',
    errorText,
    helperText,
    value = '',
    customKeyboardType = KeyboardTypes.VisiblePassword,
    inverted = false,
    prefix,
    SuffixIcon,
    clearInputValue,
    secure = false,
    setValue,
    maximumLength,
    formatAmount = false,
    onPressOut,
    setTouchedProperty,
    onEndEditing,
    onFormikBlur,
    textInputProps,
    onKeyboardFocus,
    flag,
    currency,
    alwaysFocusOn = false,
    isIban = false,
    onFocus,
    setComponentFocus,
    specialCharactersAllowed = true,
    spaceAllowed = false,
    max = 200,
    numbersAllowed = true,
    onPressSuffixIcon,
    arabicAllowed = false,
    isZeroAllowed = true,
    emojisAllowed = false,
    suffixIconStyle,
    isCurrencyInput = currency !== undefined,
    isTextInputMenuShow = true,
    errorTextStyle,
    customRef = false,
    truncateTail = false,
  } = properties;
  const [fieldActive, setFieldActive] = useState(!!value);
  const [secureValue, setSecureValue] = useState(!!secure);
  const [showCloseIcon, setShowCloseIcon] = useState(false);
  const [focused, setFocused] = useState(false);
  const [showTruncateOverlay, setShowtruncateOverlay] = useState(false);
  const position = new Animated.Value(
    fieldActive || value || alwaysFocusOn ? 1 : 0,
  );
  const isError = Boolean(errorText && errorText?.length > 0);
  const theme: Theme = useNewTheme();
  const inputRef = useRef<TextInput>(null);
  const {t} = translation.useTranslation();
  const styles = getStyle({
    position,
    fieldActive,
    theme,
    inverted,
    focused,
    disabled,
    isError,
    isCurrencyInput,
  });

  useEffect(() => {
    // Move placeholder if the value is set from outside
    if ((value && !fieldActive) || alwaysFocusOn) {
      setFieldActive(true);
      Animated.timing(position, {
        toValue: 1,
        duration: 1,
        useNativeDriver: false,
        easing: Easing.ease,
      }).start();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [value]);

  useEffect(() => {
    //for reset to default state
    if (!focused && !value) {
      setComponentFocus?.(false);
      setFieldActive(false);
    }
  }, [focused, value]);

  useEffect(() => {
    if (value) {
      setTimeout(() => {
        inputRef.current?.setSelection(0, 0);
        setShowtruncateOverlay(truncateTail);
      }, 5);
    }
    // blur on keyboard hide or out press
    const keyboardHideListener = Keyboard.addListener('keyboardDidHide', () => {
      inputRef.current?.blur();
    });
    return () => {
      keyboardHideListener.remove();
    };
  }, []);

  const handleOnFocus = (e: NativeSyntheticEvent<TextInputFocusEventData>) => {
    setFocused(true);
    onKeyboardFocus?.();
    setComponentFocus?.(true);
    onFocus?.(e);
    setShowtruncateOverlay(false);
    if (!fieldActive) {
      setFieldActive(true);
      Animated.timing(position, {
        toValue: 1,
        duration: 150,
        useNativeDriver: false,
        easing: Easing.ease,
      }).start();
    }

    /* While Input Focus, Cursor Points to end of input value */
    inputRef.current?.setSelection(value.length, value.length);
  };

  const handleOnBlur = (e: NativeSyntheticEvent<TextInputFocusEventData>) => {
    setFocused(false);
    setComponentFocus?.(false);
    onFormikBlur?.(e);
    setShowtruncateOverlay(truncateTail);
    if (formatAmount) {
      if (value && !value.includes('.')) {
        setValue?.(value + '.00');
      }
    }
    if (fieldActive && value === '') {
      if (fieldActive && value === '' && !alwaysFocusOn) {
        setFieldActive(false);
        Animated.timing(position, {
          toValue: 0,
          duration: 150,
          useNativeDriver: false,
          easing: Easing.ease,
        }).start();
      }
    }

    /* While Input Blur, Cursor Points to start of input value */
    inputRef.current?.setSelection(0, 0);
  };

  const changeMode = () => {
    setShowCloseIcon(!showCloseIcon);
    setSecureValue(!secureValue);
  };

  const iconColor = () => {
    if (errorText && errorText?.length > 0) {
      return inverted ? styles.invertedIcon.color : styles.errorIcon.color;
    }
    if (focused) {
      return inverted ? styles.invertedIcon.color : styles.focusedIcon.color;
    }
    if (disabled) {
      return styles.disabledIcon.color;
    } else {
      return inverted ? styles.invertedIcon.color : styles.defaultIcon.color;
    }
  };

  const clearInput = () => {
    setValue?.('');
    clearInputValue && clearInputValue();
  };

  const getFinishedText = (text: string) => {
    let output = text;
    //This code is not needed anymore as inputs by default changed with visible-password scheme.
    //Thus user cant long press on special characters

    // if (!specialCharactersAllowed) {
    //   let allowed =
    //     /[a-zA-Z0-9\u0600-\u06FF]/
    //   if(spaceAllowed) {
    //     allowed = /[a-zA-Z0-9\u0600-\u06FF ]/
    //   }
    //   for (let i = 0; i < text.length; i++) {
    //     if (allowed.test(text[i])) {
    //       output += text[i];
    //     }
    //   }
    // } else {
    //   output = text;
    // } //RCM-1679
    let finishedText = spaceAllowed ? output : output.replace(/\s+/g, '');
    if (!emojisAllowed) {
      finishedText = finishedText.replace(EMOJI_REGEX, '');
    }
    if (!specialCharactersAllowed) {
      if (spaceAllowed) {
        finishedText = finishedText.replace(/[^a-zA-Z0-9\u0600-\u06FF ]/, '');
      } else {
        finishedText = finishedText.replace(/[^a-zA-Z0-9\u0600-\u06FF]/, '');
      }
    }

    if (!numbersAllowed) {
      finishedText = finishedText.replace(NUMERIC_REGEX, '');
    }
    if (!arabicAllowed) {
      finishedText = finishedText.replace(ARABIC_REGEX, '');
    }
    if (finishedText.length <= max) {
      return finishedText;
    } else {
      return finishedText.slice(0, max);
    }
  };

  const handleInputChange = (text: string) => {
    if (formatAmount) {
      const rawText = text.replace(/,/g, '');
      if (rawText === '' || (!isZeroAllowed && rawText === '0')) {
        setValue?.('');
        return;
      }
      const regex = /^\d+(\.\d{0,2})?$/;
      if (regex.test(rawText) || rawText === '') {
        const [integer, decimal] = rawText.split('.');
        const formattedInteger = new Intl.NumberFormat('en-US').format(
          Number(integer || ''),
        );
        let formattedText =
          decimal !== undefined
            ? `${formattedInteger}.${decimal}`
            : formattedInteger;
        if (formattedText.length && integer.length > 8) {
          return;
        }
        if (formattedText.length && decimal?.length > 2) {
          return;
        }
        if (
          formattedText.length &&
          integer.length === 9 &&
          formattedText.endsWith('.')
        ) {
          formattedText = formattedText.slice(0, -1);
        }
        setValue?.(formattedText);
      }
    } else if (isIban) {
      const finishedText = getFinishedText(text) ?? '';
      const formattedIban = formatIbanWithSpaces(finishedText);
      setValue?.(formattedIban);
    } else {
      const finishedText = getFinishedText(text) ?? '';
      setValue?.(finishedText);
      if (finishedText.length === 1) {
        setTouchedProperty && setTouchedProperty();
      }
    }
  };

  //For currency
  const currencyInputComponent = () => {
    return (
      <Pressable
        style={styles.currencyInputContainer}
        onPress={() => {
          inputRef.current?.focus();
        }}>
        <View style={styles.inputRowCurrency}>
          {isCurrencyInput && !isRTLLanguage() && (
            <CurrencyComponent currency={currency} fieldActive={fieldActive} />
          )}
          <TextInput
            ref={inputRef}
            contextMenuHidden={true}
            selectTextOnFocus={false}
            maxLength={maximumLength}
            onFocus={handleOnFocus}
            onBlur={handleOnBlur}
            value={value}
            onPressOut={onPressOut}
            editable={!disabled}
            keyboardType={customKeyboardType}
            // onChangeText={value => setValue?.(value)}
            onChangeText={handleInputChange}
            secureTextEntry={secureValue}
            autoCorrect={false}
            autoComplete="off"
            underlineColorAndroid="transparent"
            style={[
              styles.currencyInput,
              disabled && styles.disabledInputStyle,
            ]}
            onEndEditing={onEndEditing}
            selectionColor={
              inverted
                ? theme.colors['border-interactive-enabled']
                : theme.colors['border-interactive-active']
            }
            {...textInputProps}
            cursorColor={theme.colors['border-interactive-active']}
          />
          {isCurrencyInput && isRTLLanguage() && (
            <CurrencyComponent currency={currency} fieldActive={fieldActive} />
          )}
        </View>
      </Pressable>
    );
  };

  useEffect(() => {
    if (customRef === true) {
      inputRef.current?.focus();
    }
  }, [customRef]);

  return (
    <View key={id} style={styles.parentContainer}>
      <View
        style={[
          styles.container,
          focused && {...styles.focusedContainer},
          disabled && styles.disabledContainerStyle,
          isError ? styles.errorContainerStyle : null,
        ]}>
        <FlagComponent flag={flag} />
        <View style={styles.innerContainer}>
          <Animated.Text
            style={[
              styles.placeholder,
              fieldActive && styles.animatedPlacholderStyle,
              disabled && styles.disabledPlaceholderStyle,
            ]}
            numberOfLines={1}>
            {placeholder}
          </Animated.Text>
          <View style={styles.inputRow}>
            {prefix &&
              typeof prefix === 'string' &&
              (focused || value !== '') && (
                <Label
                  id="custom-input"
                  text={prefix}
                  variant={variants.bodyRegularM}
                  style={[
                    styles.prefixStyle,
                    {opacity: focused || value != '' ? 1 : 0},
                  ]}
                />
              )}
            {prefix && typeof prefix !== 'string' && (
              <View
                style={[
                  styles.prefixSymbol,
                  {opacity: focused || value != '' ? 1 : 0},
                ]}>
                {prefix}
              </View>
            )}
            {isCurrencyInput ? (
              currencyInputComponent()
            ) : (
              <>
                <TextInput
                  ref={inputRef}
                  contextMenuHidden={isTextInputMenuShow}
                  selectTextOnFocus={false}
                  maxLength={maximumLength}
                  onFocus={handleOnFocus}
                  onBlur={handleOnBlur}
                  value={value}
                  onPressOut={onPressOut}
                  editable={!disabled}
                  keyboardType={
                    secureValue ? KeyboardTypes.Default : customKeyboardType
                  }
                  // onChangeText={value => setValue?.(value)}
                  onChangeText={handleInputChange}
                  secureTextEntry={secureValue}
                  autoCorrect={false}
                  autoComplete="off"
                  importantForAutofill="no"
                  textContentType="none"
                  spellCheck={false}
                  underlineColorAndroid="transparent"
                  style={[
                    styles.input,
                    showTruncateOverlay && {color: 'transparent'},
                    disabled && styles.disabledInputStyle,
                  ]}
                  onEndEditing={onEndEditing}
                  selectionColor={
                    inverted
                      ? theme.colors['border-interactive-enabled']
                      : theme.colors['border-interactive-active']
                  }
                  {...textInputProps}
                  cursorColor={theme.colors['border-interactive-active']}
                />
                {showTruncateOverlay && (
                  <View style={styles.truncateOverlay}>
                    <Label
                      id="id"
                      text={value ?? ''}
                      textProps={{ellipsizeMode: 'tail', numberOfLines: 1}}
                      style={[styles.input, {textAlign: 'left', paddingTop: 0}]} // paddingTop as per Label comp style
                    />
                  </View>
                )}
              </>
            )}
          </View>
        </View>
        {focused && value !== '' && !disabled && (
          <Pressable style={styles.cancelContainer} onPress={clearInput}>
            <Cancel_01 color={iconColor()} />
          </Pressable>
        )}
        {secure && (focused || value !== '') && (
          <Pressable
            style={styles.cancelContainer}
            onPress={disabled ? undefined : changeMode}>
            {showCloseIcon ? (
              <EyeCloseComponent stroke={iconColor()} />
            ) : (
              <EyeOpenComponent stroke={iconColor()} />
            )}
          </Pressable>
        )}
        {SuffixIcon && (
          <Pressable onPress={onPressSuffixIcon} style={styles.cancelContainer}>
            <View style={[styles.cancelContainer, suffixIconStyle]}>
              <SuffixIcon />
            </View>
          </Pressable>
        )}
      </View>
      {errorText && errorText?.length > 0 && (
        <View style={[styles.errorTextContainer, errorTextStyle]}>
          <ErrorText id="custom-input" errorText={t(errorText)} />
          {/* {currency && (
            <CurrencyComponent
              currency={currency}
              fieldActive={fieldActive}
              color={theme.colors['content-semantic-error-01']}
            />
          )} */}
        </View>
      )}
      {helperText && helperText?.length > 0 && (
        <View style={styles.helperText}>
          <HelperText id="custom-input" helperText={t(helperText)} />
          {currency && (
            <CurrencyComponent currency={currency} fieldActive={fieldActive} />
          )}
        </View>
      )}
    </View>
  );
};

const FlagComponent = ({flag}) => {
  const theme = useNewTheme();
  const styles = getFlagComponentStyle({theme});
  return flag ? (
    <View style={styles.flagContainer}>
      <RemoteSvg uri={flag} size={24} />
    </View>
  ) : null;
};

export const CurrencyComponent = ({
  currency,
  fieldActive,
  color = useNewTheme().colors['content-secondary'],
}) => {
  const theme: Theme = useNewTheme();
  const styles = getCurrencyComponentStyle({theme});
  return currency && fieldActive ? (
    <View style={styles.currencyContainer}>
      <Currency
        currencyType={currency ?? 'SAR'}
        iconProps={{
          color: color,
          size: Size['size-01'],
        }}
      />
    </View>
  ) : null;
};

export {Input};


###FilePath: custom-input/styles.ts

import {Typography} from '@app/utils';
import {Platform, StyleSheet} from 'react-native';
import {CustomInputStyleParams} from './type';
import {getForcedLTRDirection, isRTLLanguage} from 'app/utils/language-utils';
import {getCurrentLanguage, getFontStyles, Language} from 'react-core';
import {variants} from '../label/types';
export const getStyle = ({
  position,
  fieldActive,
  theme,
  inverted,
  focused,
  disabled,
  isError,
  isCurrencyInput,
}: CustomInputStyleParams) => {
  return StyleSheet.create({
    parentContainer: {
      display: 'flex',
      gap: 8,
      width: '100%',
      padding: 0,
      flexDirection: 'column',
      justifyContent: 'center',
      alignItems: 'flex-start',
    },
    inputRow: {
      display: 'flex',
      gap: 8,
      flexDirection: getForcedLTRDirection(),
    },
    inputRowCurrency: {
      display: 'flex',
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    container: {
      display: 'flex',
      flexDirection: 'row',
      gap: 16,
      height: 64,
      borderWidth: 1,
      borderColor: '#FFFFFF00',
      width: '100%',
      backgroundColor: inverted
        ? theme.colors['surface-interactive-secondary-inverted-enabled']
        : theme.colors['surface-interactive-secondary-enabled'],
      paddingHorizontal: 16,
      borderRadius: 8,
      alignItems: 'center',
      alignSelf: 'stretch',
    },
    innerContainer: {
      flex: 1,
      display: 'flex',
      justifyContent: fieldActive ? 'flex-end' : 'center',
      gap: 4,
    },
    placeholder: {
      ...(fieldActive ? {} : {position: 'absolute'}),
      color: inverted
        ? theme.colors['content-inverted-secondary']
        : theme.colors['content-secondary'],
      ...getFontStyles(variants.bodyRegularM, getCurrentLanguage() as Language),
      textAlign: 'left',
      writingDirection: 'ltr',
    },

    input: {
      color: inverted
        ? theme.colors['content-inverted-primary']
        : theme.colors['content-primary'],
      // width: isRTLLanguage() && isCurrencyInput ? 'auto' : '100%',
      // lineHeight: Platform.OS === 'ios' ? 0 : 24, // lineHeight is overwritten
      height: 24,
      padding: 0,
      flex: 1,
      textAlignVertical: 'center',
      // paddingHorizontal: isRTLLanguage() ? 14 : 0,
      textAlign: isRTLLanguage() ? 'right' : 'left',
      writingDirection: isRTLLanguage() ? 'rtl' : 'ltr',
      // fontVariant: ['tabular-nums'],
      ...getFontStyles(variants.bodyRegularM, getCurrentLanguage() as Language),
      ...(isRTLLanguage()
        ? Platform.select({ios: {lineHeight: 28}})
        : {lineHeight: 19.5}), // changing this because it's breaking in arabic for english text
      minWidth: 100, // added min width to fix cropping issue in smaller devices
      fontWeight: 400,
    },
    currencyInput: {
      color: inverted
        ? theme.colors['content-inverted-primary']
        : theme.colors['content-primary'],
      width: isRTLLanguage() && isCurrencyInput ? 'auto' : '100%',
      padding: 0,
      height: 24,
      textAlign: isRTLLanguage() ? 'right' : 'left',
      ...getFontStyles(variants.bodyRegularM, getCurrentLanguage() as Language),
      ...(isRTLLanguage()
        ? Platform.select({ios: {lineHeight: 28}})
        : {lineHeight: 19.5}),
      //marginTop: Platform.OS === 'ios' ? 16 : 0,
    },
    truncateOverlay: {
      flexDirection: getForcedLTRDirection(),
      position: 'absolute',
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      alignItems: 'center',
      pointerEvents: 'none',
    },
    animatedPlacholderStyle: {
      height: 16,
      top: position.interpolate({
        inputRange: [0, 1],
        outputRange: [20, 0],
      }),
      ...getFontStyles(
        variants.bodyRegularXS,
        getCurrentLanguage() as Language,
      ),
    },
    focusedContainer: {
      borderWidth: 1,
      borderColor: inverted
        ? theme.colors['border-interactive-inverted-active']
        : theme.colors['border-interactive-active'],
    },
    cancelContainer: {
      justifyContent: 'center',
      // alignSelf: 'center',
      height: 24,
      width: 24,
      padding: 5,
      alignItems: 'center',
    },
    disabledContainerStyle: {
      backgroundColor: theme.colors['surface-interactive-secondary-disabled'],
      borderWidth: 0,
    },
    disabledPlaceholderStyle: {
      color: inverted
        ? theme.colors['content-inverted-disabled']
        : theme.colors['content-disabled'],
    },
    disabledInputStyle: {
      color: theme.colors['content-disabled'],
    },
    errorContainerStyle: {
      backgroundColor: inverted
        ? theme.colors['surface-interactive-secondary-inverted-enabled']
        : theme.colors['surface-semantic-error-01'],
      borderColor: inverted
        ? theme.colors['border-semantic-error-inverted']
        : theme.colors['border-semantic-error'],
      borderWidth: 1,
    },
    bottomContainerStyle: {
      display: 'flex',
      flexDirection: 'row',
      gap: 4,
      paddingLeft: 16,
    },
    errorText: {
      color: inverted
        ? theme.colors['content-semantic-error-inverted']
        : theme.colors['border-semantic-error'],
      justifyContent: 'center',
      ...getFontStyles(
        variants.bodyRegularXS,
        getCurrentLanguage() as Language,
      ),
    },
    alertIconContainer: {
      width: 12,
      height: 16,
      justifyContent: 'center',
    },
    eyeOpen: {
      color: focused
        ? theme.colors['icon-interactive-secondary-active']
        : theme.colors['icon-interactive-secondary-enabled'],
    },
    focusedIcon: {
      color: theme.colors['icon-interactive-secondary-active'],
    },
    invertedIcon: {
      color: isError
        ? theme.colors['icon-semantic-error-01']
        : theme.colors['icon-interactive-inverted-active'],
    },
    errorIcon: {
      color: theme.colors['icon-semantic-error-01'],
    },
    prefixStyle: {
      color: theme.colors['content-disabled'],
      textAlignVertical: 'center',
      height: 24,
      paddingBottom: isRTLLanguage() && Platform.OS === 'ios' ? 0 : undefined,
      paddingTop: isRTLLanguage() && Platform.OS === 'android' ? 0 : undefined,
      ...(isRTLLanguage() ? {} : {}),
    },
    disabledIcon: {
      color: theme.colors['icon-interactive-secondary-enabled'],
    },
    defaultIcon: {
      color: disabled
        ? theme.colors['icon-interactive-inverted-disabled']
        : theme.colors['icon-interactive-secondary-enabled'],
    },
    prefixSymbol: {
      justifyContent: 'center',
      paddingRight: 10,
      width: 15,
    },
    helperText: {
      flexDirection: 'row',
      gap: 1,
      maxWidth: '95%',
    },
    errorTextContainer: {
      flexDirection: 'row',
      gap: 1,
    },
    currencyInputContainer: {
      width: '100%',
      height: '100%',
    },
  });
};

export const getFlagComponentStyle = ({theme}) => {
  return StyleSheet.create({
    /* Flag Component Style */
    flagContainer: {
      borderRadius: 999,
      height: 24,
      width: 24,
      backgroundColor: theme.colors['background-01'],
      alignSelf: 'center',
      overflow: 'hidden',
    },
  });
};

export const getCurrencyComponentStyle = ({}) => {
  return StyleSheet.create({
    /* Currency Component Style */
    currencyContainer: {
      alignContent: 'center',
      justifyContent: 'center',
      height: 24,
      //marginTop: Platform.OS === 'ios' ? 26 : 0,
    },
  });
};


###FilePath: custom-input/type.ts

import {KeyboardTypes} from 'app/constants';
import {Theme} from 'react-core';
import {useRef} from 'react';
import {
  Animated,
  NativeSyntheticEvent,
  TextInput,
  StyleProp,
  TextInputFocusEventData,
  TextInputProps,
  ViewStyle,
} from 'react-native';

export type InputProperties = {
  id: string;
  disabled?: boolean;
  placeholder?: string;
  errorText?: string | false | undefined;
  helperText?: string;
  value?: string;
  setValue?: (value: string) => void;
  clearInputValue?: () => void;
  inverted?: boolean;
  customKeyboardType?: KeyboardTypes;
  prefix?: React.ReactNode | string;
  SuffixIcon?: any;
  secure?: boolean;
  maximumLength?: number;
  formatAmount?: boolean;
  onPressOut?: () => void;
  onPressSuffixIcon?: () => void;
  setTouchedProperty?: () => void;
  onEndEditing?: () => void;
  onFormikBlur?: (e: NativeSyntheticEvent<TextInputFocusEventData>) => void;
  textInputProps?: TextInputProps;
  onKeyboardFocus?: () => void;
  alwaysFocusOn?: boolean;
  isIban?: boolean;
  setComponentFocus?: (status: boolean) => void;
  flag?: string;
  currency?: string;
  onFocus?: (e: NativeSyntheticEvent<TextInputFocusEventData>) => void;
  onBlur?: (e: NativeSyntheticEvent<TextInputFocusEventData>) => void;
  specialCharactersAllowed?: boolean;
  spaceAllowed?: boolean;
  max?: number;
  numbersAllowed?: boolean;
  arabicAllowed?: boolean;
  isZeroAllowed?: boolean;
  emojisAllowed?: boolean;
  getFocusOut?: () => void;
  suffixIconStyle?: StyleProp<ViewStyle>;
  isCurrencyInput?: boolean;
  isTextInputMenuShow?: boolean;
  customRef?: boolean;
  errorTextStyle?: StyleProp<ViewStyle>;
  truncateTail?: boolean;
};

export type CustomInputStyleParams = {
  position: Animated.Value;
  fieldActive: boolean;
  theme: Theme;
  inverted: boolean;
  focused: boolean;
  disabled: boolean;
  isError: boolean;
  isCurrencyInput: boolean;
};


